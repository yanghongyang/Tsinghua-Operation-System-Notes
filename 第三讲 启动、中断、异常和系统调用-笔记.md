<!--
 * @Description: 
 * @Author: Hongyang_Yang
 * @Date: 2020-08-04 16:00:50
 * @LastEditors: Hongyang_Yang
 * @LastEditTime: 2020-08-07 17:59:16
-->
# BIOS
## 计算机体系结构概述
CPU：计算能力，执行指令

内存：存储能力，存储程序运行的代码和数据

I/O设备：和外界交互

**CPU加电之后，其执行的第一条指令在哪里？**
- 在内存里
  
**但是内存在断电之后再加电，数据都被清空了，那么第一条指令在哪里呢？**
- 内存分为RAM，ROM
- ROM只读存储中存储之前写入的内容（即系统初始化代码）
- 第一条指令从系统初始化代码开始执行
  
## 启动时计算机内存和磁盘布局

```CS:IP=0xf000:fff0```

(CS：代码段寄存器；
IP：指令指针寄存器)

系统处于实模式。

```PC=16*CS + IP```

地址总线只有20位地址空间，也就是2^20=1MB

在BIOS启动固件中，需要提供：
1. 基本输入输出的程序
2. 系统设置信息
3. 开机后自检程序
4. 系统自启动程序

## 加载程序的内存地址空间
### BIOS
1. 将加载程序从磁盘的引导扇区（512字节）加载到0x7c00。
2. 跳转到CS:IP=0000:7c00。（即加载程序）

### 加载程序
1. 将操作系统的代码和数据从硬盘加载到内存当中。
2. 跳转到操作系统的起始地址。将控制权交给操作系统。
3. 使用加载程序来识别文件系统（因为文件系统是多种多样的，所以硬盘没有办法直接识别文件系统）。

## BIOS系统调用
### BIOS以中断调用的方式提供了基本的I/O功能
1. INT 10h:字符显示
2. INT 13h:磁盘扇区读写
3. INT 15h:检测内存大小
4. INT 16h:键盘输入

### 在Intel CPU下只能以x86实模式下使用

# 系统启动规范
加电之后读BIOS，BIOS读加载程序，加载程序读内核映像。

实际上由于不同分区的存在，可能在每个分区都存在不同的操作系统，因此BIOS在读取加载程序之前，首先需要读**主引导记录**（BIOS读取主引导扇区代码）。

接着，主引导扇区代码读取**活动分区**的引导扇区代码。

之后，引导扇区代码读取文件系统的**加载程序**。

因此需要了解主引导扇区代码等的格式是什么样子。

## CPU初始化
CPU加电稳定后从0xffff0读第一条指令
1. CS:IP=0xf000:fff0
2. 第一条指令是跳转指令

CPU初始状态是16位实模式
1. CS:IP是16位寄存器
2. 指令指针PC=16*CS+IP
3. 最大地址空间是1MB

## BIOS初始化过程
1. 硬件自检POST
2. 检测系统中内存和显卡等关键部件的存在和工作状态
3. 查找并执行显卡等接口卡BIOS，进行设备初始化
4. 执行系统BIOS，进行系统监测
   1. 检测和配置系统中安装的即插即用设备

5. 更新CMOS中的扩展系统配置数据ESCD
6. 按指定启动顺序从软盘、硬盘或光驱中启动

## 主引导记录**MBR**格式（512字节）
启动代码：446字节
1. 检查分区表正确性
2. 加载并跳转到磁盘上的引导程序

硬件分区表：64字节
1. 描述分区状态和位置
2. 每个分区描述信息占据16字节（最多只能有4个分区）

结束标志字：2字节（55AA）
1. 主引导记录的有效标志

## 分区引导扇区格式
JMP（跳转指令）：跳转到启动代码
1. 与平台相关代码

文件卷头：文件系统描述信息

启动代码：跳转到加载程序

结束标志：55AA

## 加载程序（bootloader）
加载程序是可以认识文件系统的格式的。加载程序从文件系统中读取启动配置信息。

启动配置信息（启动菜单）中有可选的操作系统内核列表和加载参数。

接着，加载程序依据配置加载指定内核并跳转到内核执行。也就到了操作系统内核。

## 系统启动规范
BIOS
1. 固化到计算机主板上的程序
2. 包括系统设置、自检程序和系统自启动程序。
3. BIOS-MBR（最多只能有4个分区）、BIOS-GPT（可以描述更多分区）、PXE（联机、可以从网络启动）

UEFI
1. 接口标准
2. 在所有平台上一致的操作系统启动服务

# 中断、异常和系统调用比较
为什么需要中断、异常和系统调用
1. 在计算机运行中，内核是被信任的第三方
2. 只有内核可以执行特权指令
3. 方便应用程序

中断和异常希望解决的问题
1. 当外设连接计算机时，会出现什么现象？
2. 当应用程序处理意想不到的行为时，会出现什么现象？

系统调用希望解决的问题
1. 用户应用程序时如何得到系统服务的？
2. 系统调用和功能调用的不同之处是什么？

## 内核的进入与退出

## 中断、异常和系统调用
系统调用（system call）
1. 应用程序**主动**向操作系统发出的服务请求

异常（exception）
1. 非法指令或其他原因导致当前**指令执行失败**（如：内存出错）后的处理请求

中断（hardware interrupt）
1. 来自硬件设备的处理请求

## 中断、异常和系统调用比较
**源头**
1. 中断：外设
2. 异常：应用程序意想不到的行为
3. 系统调用：应用程序请求操作提供服务

**响应方式**
1. 中断：异步
2. 异常：同步
3. 系统调用：异步或同步

**处理机制**
1. 中断：持续，对用户应用程序是透明的
2. 异常：杀死或者重新执行意想不到的应用程序指令
3. 系统调用：等待和持续

**中断处理机制**
1. 硬件处理
   1. 在CPU初始化时设置中断使能标志
      1. 依据内部或外部事件设置中断标志
      2. 依据中断向量调用相应中断服务例程
2. 软件
   1. 现场保存（编辑器）
   2. 中断服务处理（服务例程）
   3. 清除中断标记（服务例程）
   4. 现场恢复（编译器）

## 中断嵌套
1. 硬件中断服务例程可被打断
   1. 不同硬件中断源可能硬件中断处理时出现
   2. 硬件中断服务例程中需要临时禁止中断请求
   3. 中断请求会保持到CPU做出响应
2. 异常服务例程可被打断
   1. 异常服务例程执行时可能出现硬件中断
3. 异常服务例程可嵌套
   1. 异常服务例程可能出现缺页

# 系统调用
