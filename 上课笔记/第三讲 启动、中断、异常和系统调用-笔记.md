<!--
 * @Description:
 * @Author: Hongyang_Yang
 * @Date: 2020-08-04 16:00:50
 * @LastEditors: Hongyang_Yang
 * @LastEditTime: 2020-08-08 20:55:52
-->

# BIOS

## 计算机体系结构概述

CPU：计算能力，执行指令

内存：存储能力，存储程序运行的代码和数据

I/O 设备：和外界交互

**CPU 加电之后，其执行的第一条指令在哪里？**

- 在内存里

**但是内存在断电之后再加电，数据都被清空了，那么第一条指令在哪里呢？**

- 内存分为 RAM，ROM
- ROM 只读存储中存储之前写入的内容（即系统初始化代码）
- 第一条指令从系统初始化代码开始执行

## 启动时计算机内存和磁盘布局

`CS:IP=0xf000:fff0`

(CS：代码段寄存器；
IP：指令指针寄存器)

系统处于实模式。

`PC=16*CS + IP`

地址总线只有 20 位地址空间，也就是 2^20=1MB

在 BIOS 启动固件中，需要提供：

1. 基本输入输出的程序
2. 系统设置信息
3. 开机后自检程序
4. 系统自启动程序

## 加载程序的内存地址空间

### BIOS

1. 将加载程序从磁盘的引导扇区（512 字节）加载到 0x7c00。
2. 跳转到 CS:IP=0000:7c00。（即加载程序）

### 加载程序

1. 将操作系统的代码和数据从硬盘加载到内存当中。
2. 跳转到操作系统的起始地址。将控制权交给操作系统。
3. 使用加载程序来识别文件系统（因为文件系统是多种多样的，所以硬盘没有办法直接识别文件系统）。

## BIOS 系统调用

### BIOS 以中断调用的方式提供了基本的 I/O 功能

1. INT 10h:字符显示
2. INT 13h:磁盘扇区读写
3. INT 15h:检测内存大小
4. INT 16h:键盘输入

### 在 Intel CPU 下只能以 x86 实模式下使用

# 系统启动规范

加电之后读 BIOS，BIOS 读加载程序，加载程序读内核映像。

实际上由于不同分区的存在，可能在每个分区都存在不同的操作系统，因此 BIOS 在读取加载程序之前，首先需要读**主引导记录**（BIOS 读取主引导扇区代码）。

接着，主引导扇区代码读取**活动分区**的引导扇区代码。

之后，引导扇区代码读取文件系统的**加载程序**。

因此需要了解主引导扇区代码等的格式是什么样子。

## CPU 初始化

CPU 加电稳定后从 0xffff0 读第一条指令

1. CS:IP=0xf000:fff0
2. 第一条指令是跳转指令

CPU 初始状态是 16 位实模式

1. CS:IP 是 16 位寄存器
2. 指令指针 PC=16\*CS+IP
3. 最大地址空间是 1MB

## BIOS 初始化过程

1. 硬件自检 POST
2. 检测系统中内存和显卡等关键部件的存在和工作状态
3. 查找并执行显卡等接口卡 BIOS，进行设备初始化
4. 执行系统 BIOS，进行系统监测

   1. 检测和配置系统中安装的即插即用设备

5. 更新 CMOS 中的扩展系统配置数据 ESCD
6. 按指定启动顺序从软盘、硬盘或光驱中启动

## 主引导记录**MBR**格式（512 字节）

启动代码：446 字节

1. 检查分区表正确性
2. 加载并跳转到磁盘上的引导程序

硬件分区表：64 字节

1. 描述分区状态和位置
2. 每个分区描述信息占据 16 字节（最多只能有 4 个分区）

结束标志字：2 字节（55AA）

1. 主引导记录的有效标志

## 分区引导扇区格式

JMP（跳转指令）：跳转到启动代码

1. 与平台相关代码

文件卷头：文件系统描述信息

启动代码：跳转到加载程序

结束标志：55AA

## 加载程序（bootloader）

加载程序是可以认识文件系统的格式的。加载程序从文件系统中读取启动配置信息。

启动配置信息（启动菜单）中有可选的操作系统内核列表和加载参数。

接着，加载程序依据配置加载指定内核并跳转到内核执行。也就到了操作系统内核。

## 系统启动规范

BIOS

1. 固化到计算机主板上的程序
2. 包括系统设置、自检程序和系统自启动程序。
3. BIOS-MBR（最多只能有 4 个分区）、BIOS-GPT（可以描述更多分区）、PXE（联机、可以从网络启动）

UEFI

1. 接口标准
2. 在所有平台上一致的操作系统启动服务

# 中断、异常和系统调用比较

为什么需要中断、异常和系统调用

1. 在计算机运行中，内核是被信任的第三方
2. 只有内核可以执行特权指令
3. 方便应用程序

中断和异常希望解决的问题

1. 当外设连接计算机时，会出现什么现象？
2. 当应用程序处理意想不到的行为时，会出现什么现象？

系统调用希望解决的问题

1. 用户应用程序时如何得到系统服务的？
2. 系统调用和功能调用的不同之处是什么？

## 内核的进入与退出

## 中断、异常和系统调用

系统调用（system call）

1. 应用程序**主动**向操作系统发出的服务请求

异常（exception）

1. 非法指令或其他原因导致当前**指令执行失败**（如：内存出错）后的处理请求

中断（hardware interrupt）

1. 来自硬件设备的处理请求

## 中断、异常和系统调用比较

**源头**

1. 中断：外设
2. 异常：应用程序意想不到的行为
3. 系统调用：应用程序请求操作提供服务

**响应方式**

1. 中断：异步
2. 异常：同步
3. 系统调用：异步或同步

**处理机制**

1. 中断：持续，对用户应用程序是透明的
2. 异常：杀死或者重新执行意想不到的应用程序指令
3. 系统调用：等待和持续

**中断处理机制**

1. 硬件处理
   1. 在 CPU 初始化时设置中断使能标志
      1. 依据内部或外部事件设置中断标志
      2. 依据中断向量调用相应中断服务例程
2. 软件
   1. 现场保存（编辑器）
   2. 中断服务处理（服务例程）
   3. 清除中断标记（服务例程）
   4. 现场恢复（编译器）

## 中断嵌套

1. 硬件中断服务例程可被打断
   1. 不同硬件中断源可能硬件中断处理时出现
   2. 硬件中断服务例程中需要临时禁止中断请求
   3. 中断请求会保持到 CPU 做出响应
2. 异常服务例程可被打断
   1. 异常服务例程执行时可能出现硬件中断
3. 异常服务例程可嵌套
   1. 异常服务例程可能出现缺页

# 系统调用

## 标准 C 库的例子

1. 应用程序调用 printf()时，会触发系统调用 write()。

系统调用

- 操作系统服务的编程接口
- 通常由高级语言编写（C 或者 C++）
- 程序访问通常是通过高层次的 API 接口而不是直接进行系统调用
- 三种最常用的应用程序编程接口(API)
  - Win32 API 用于 Windows
  - POSIX API 用于 POSIX-based systems（包括 UNIX, LINUX, Mac OS 的所有版本）
  - Java API 用于 JAVA 虚拟机（JVM）

## 系统调用的实现

1. 每个系统调用对应一个系统调用号
   1. 系统调用接口根据系统调用号来维护表的索引
2. 系统调用接口调用内核态的系统调用功能实现，并返回系统调用的状态和结果
3. 用户不需要知道系统调用的实现
   1. 需要设置调用参数和获取返回结果
   2. 操作系统接口的细节大部分都隐藏在应用编程接口后
      1. 通过运行程序支持的库来管理

## 函数调用和系统调用的不同处

1. 系统调用
   1. INT 和 IRET 指令用于系统调用
      1. 系统调用时，堆栈切换和特权级的转换
2. 函数调用
   1. CALL 和 RET 用于常规调用
      1. 常规调用时没有堆栈切换

## 中断、异常恶化系统调用的开销

1. 超过函数调用
2. 中断、异常和系统调用
   1. 引导机制（切换引导）
   2. 建立内核堆栈（第一次调用的时候）
   3. 验证参数（参数的有效性、合法性）
   4. 内核态映射到用户态的地址空间
      1. 更新页面映射权限
   5. 内核态独立地址空间
      1. TLB

# 系统调用示例

## 文件复制过程中的系统调用序列

#define SYS_write 5
#define SYS_read 6
#define SYS_close 7
#define SYS_open 10

在 ucore 中库函数 read()的功能是读文件

- user/libs/file.h: int read(int fd, void \*buf, int length)

库函数 read()的参数和返回值

- int fd ——文件句柄
- void \*buf——数据缓冲区指针
- int length ——数据缓冲区长度
- int return_value ——返回读出数据长度

库函数 read()使用示例

- int sfs_filetest1.c: ret = read(fd, data, len);

## ucore 系统调用 read(fd, buffer, length)的实现

1. kern/trap/trapentry.S: alltraps()
2. kern/trap/trap.c: trap()
   - tf -> trapno == T_SYSCALL
3. kern/syscall/syscall.c: syscall()
   - tf -> tf_regs.reg_eax==SYS_read
4. kern/syscall/syscall.c:sys_read()
   - 从 tf->sp 获取 fd, buf, length
5. kern/fs/sysfile.c:sysfile_read()
   - 读取文件
6. kern/trap/trapentry.S: trapret()

# ucore+系统调用代码

safe_read 里调用了 read()函数
步骤和*ucore 系统调用 read(fd, buffer, length)的实现*相同
