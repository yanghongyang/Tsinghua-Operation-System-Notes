<!--
 * @Description: 
 * @Author: Hongyang_Yang
 * @Date: 2020-08-10 21:38:36
 * @LastEditors: Hongyang_Yang
 * @LastEditTime: 2020-08-12 12:13:52
-->
# 计算机体系结构和内存层次
## 内容摘要
- 计算机体系结构/内存层次
  - 计算机体系结构
  - 内存层次
  - 操作系统的内存管理方式

- 地址空间 & 地址生成
  - 地址空间的定义
  - 地址生成
  - 地址检查


- 连续内存分配
  - 内存碎片
  - 动态分配
    - 最先匹配
    - 最佳匹配
    - 最差匹配
  - 碎片整理
    - 紧凑（compaction）
    - 分区对换（swap in/out）

- 伙伴系统
  - 伙伴系统的实现
  - ucore中的伙伴系统

## 计算机体系结构
计算机系统包括 **CPU、内存、I/O设备**。

## 内存层次
（见PPT上画的图）

## 操作系统的内存管理
以字节为单位进行访问，每一个字节有自己的一个地址（物理地址）

**目的**
- 抽象
  - 逻辑地址空间

- 保护
  - 独立地址空间

- 共享
  - 访问相同内存

- 虚拟化
  - 更大的地址空间

## 操作系统的内存管理方式
- 操作系统中采用的内存管理方式
  - 重定位（`relocation`）
  - 分段（`segmentation`）
  - 分页（`paging`）
  - 虚拟存储（`virtual memory`）
    - 目前多数系统（`Linux`）采用按需页式虚拟存储

- 实现**高度依赖**硬件
  - 与计算机存储架构紧耦合
  - MMU（内存管理单元）：处理CPU存储访问请求的硬件

## 地址空间和地址生成
### 地址空间定义
- 物理地址空间 - 硬件支持的地址空间
  - 起始地址0，直到Max<sub>sys</sub>

- 逻辑地址空间 - 在CPU运行的进程看到的地址
  - 起始地址0，直到Max<sub>prog</sub>

### 逻辑地址生成
编译 -> 汇编 -> 链接 -> 程序加载（重定位）

### 地址生成时机和限制
- 编译时（例如，功能手机（不是智能机！！！））
  - 假设起始地址已知
  - 如果起始地址改变，必须**重新编译**

- 加载时（例如，可执行文件中有一个可重定位表）
  - 如编译时起始位置未知，编译器需生成可重定位的代码（relocatable code）
  - 加载时，生成**绝对地址**

- 执行时（例如，使用虚拟存储的系统）
  - 执行时代码可移动
  - 需地址转换（映射）硬件支持

从 **灵活性** 讲，**执行时** 生成地址最好；而 **编译时** 和 **加载时** 生成地址的优点是 **简单**。（编译时和加载时的地址是写死的）

### 地址生成过程
- CPU
  - ALU : 需要逻辑地址的内存内容
  - MMU : 进行逻辑地址和物理地址的转换
  - CPU控制逻辑 : 给总线发送物理地址请求

- 内存
  - 发送物理地址的内容给CPU
  - 或接收CPU数据到物理地址

- 操作系统
  - 建立逻辑地址LA和物理地址PA的映射

### 地址检查
（见PPT P4图）

## 连续内存分配
### 连续内存分配和内存碎片
- 连续内存分配
  - 给进程分配一块不小于指定大小的连续的物理内存区域

- 内存碎片
  - 空闲内存不能被利用

- 外部碎片
  - **分配单元之间**的未被使用内存

- 内部碎片
  - **分配单元内部**的未被使用内存
  - 取决于分配单元大小是否要取整

### 连续内存分配：动态分区分配
- 动态分区分配
  - 当程序被加载执行时，分配一个进程指定大小可变的区块（块、内存块）
  - 分区的地址是连续的

- 操作系统需要维护的数据结构
  - 所有进程的已分配分区
  - 空闲分区（Empty-blocks）

- 动态分区分配策略
  - 最先匹配（First-fit）
  - 最佳匹配（Best-fit）
  - 最差匹配（Worst-fit）

### 最先匹配策略
**思路**

```分配n个字节，使用第一个科用的空间比n打的空闲块。```

**原理 & 实现**
- 空闲分区列表按地址顺序排序
- 分配过程中，搜索第一个合适的分区
- 释放分区时，检查是否可与临近的空闲分区合并

**优点**
- 简单
- 在高地址空间有大块的空闲分区

**缺点**
- 外部碎片
- 分配大块时较慢（因为前面的小块碎片太多了）

### 最佳匹配策略
**思路**

```分配n字节分区时，查找并使用不小于n的最小空闲分区。```

**原理 & 实现**
- 空闲分区列表按照大小排序
- 分配时，查找一个合适的分区
- 释放时，查找并且合并临近的空闲分区（如果找到）

**优点**
- 大部分分配的尺寸较小时，效果很好
  - 可避免大的空闲分区被拆分
  - 可减小外部碎片的大小
  - 相对简单

**缺点**

- 外部碎片
- 释放分区较慢
- 容易产生很多无用的小碎片

### 最差匹配策略

**思路**

```分配n个字节，使用尺寸不小于n的最大空闲分区。```

**原理 & 实现**

- 空闲分区列表按由大到小排序
- 分配时，选最大的分区
- 释放时，检查是否可与临近的空闲分区合并，进行可能的合并，并调整空闲分区列表顺序

**优点**

- 中等大小的分配较多时，效果最好
- 避免出现太多的小碎片

**缺点**

- 释放分区较慢
- 外部碎片
- 容易破坏大的空闲分区，因此后续难以分配大的分区

### 碎片整理：紧凑（compaction）
- 碎片整理
  - 通过调整进程占用的分区位置来减少或避免分区碎片

- 碎片紧凑
  - 通过移动分配给进程的内存分区，以合并外部碎片
  - 碎片紧凑的条件
    - 所有的应用程序可动态重定位
  - 需要解决的问题
    - 什么时候移动？
    - 开销

### 碎片整理：分区对换（Swappint in/out）
- 通过抢占并回收处于**等待状态**进程的分区，以增大可用内存空间

## 伙伴系统
### 伙伴系统（Buddy System）
- 整个可分配的分区大小为2<sup>u</sup>
- 需要的分区大小为2<sup>U-1</sup> < s <= 2<sup>U</sup>时，把整个块分配给该进程；

### 伙伴系统的实现
- 数据结构
  - 空闲块按大小和起始地址组织成二维数组
  - 初始状态：只有一个大小为2<sup>U</sup>的空闲块

- 分配过程
  - 由小到大在空闲块数组中找最小的可用空闲块
  - 如空闲块过大，对可用空闲块进行二等分，直到得到合适的可用空闲块

### 伙伴系统中的内存分配

### 伙伴系统的实现
- 释放过程
  - 把释放的块放入空闲块数组
  - 合并满足合并条件的空闲块

- 合并条件
  - 大小相同2<sup>i</sup>
  - 地址相邻
  - 相邻两块中，地址低的块的起始地址必须是2<sup>(i+1)</sup>的倍数

当前的Linux和Unix系统中都有Buddy System的实现，其被用来做内核里的存储分配。

### ucore中的物理内存管理

### ucore中的伙伴系统实现
