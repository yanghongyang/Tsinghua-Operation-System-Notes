<!--
 * @Description: 
 * @Author: Hongyang_Yang
 * @Date: 2020-09-23 08:22:08
 * @LastEditors: Hongyang_Yang
 * @LastEditTime: 2020-09-23 11:18:34
-->
# 进程和线程
## 进程
### 进程的概念
### 进程控制块
### 进程状态
### 三状态进程模型
### 挂起进程模型
## 线程
### 为什么引入线程
### 线程的概念
### 用户线程
### 内核线程

## 进程
### 进程的概念
1. 进程是指一个具有一定**独立功能**的程序在一个**数据集合**上的一次**动态执行**过程。
2. 进程包含了正在运行的一个程序的**所有状态**信息。
   1. 代码
   2. 数据
   3. 状态寄存器
      1. CPU状态 CR0、指令指针IP
   4. 通用寄存器
      1. AX、BX、CX...
   5. 进程占用系统资源
      1. 打开文件、已分配内存...

3. 进程的特点
   1. 动态性
      1. 可动态地创建、结束进程
   2. 并发性
      1. 进程可以被独立调度并占用处理机运行
   3. 独立性
      1. 不同进程的工作不相互影响
   4. 制约性
      1. 因访问共享数据/资源或进程间同步而产生制约

#### 进程与程序的联系
1. 进程是操作系统处于执行状态程序的抽象
   1. 程序=文件（静态的可执行文件）
   2. 进程=执行中的程序=程序+执行状态
2. 同一个程序的多次执行过程对应为不同进程
   1. 如命令“ls”的多次执行对应多个进程
3. 进程执行需要的资源
   1. 内存：保存代码和数据
   2. CPU：执行指令

#### 进程与程序的区别
1. 进程是动态的，程序是静态的
   1. 程序是有序代码的集合
   2. 进程是程序的执行，进程有核心态/用户态
2. 进程是暂时的，程序是永久的
   1. 进程是一个状态变化的过程
   2. 程序可长久保存
3. 进程与程序的组成不同
   1. 进程的组成包括程序、数据和进程控制块

### 进程控制块(PCB, Process Control Block)
1. 概念：操作系统管理控制进程运行所用的信息集合
   1. 操作系统用PCB来描述进程的基本情况以及运行变化的过程
   2. PCB是进程存在的唯一标志
      1. 每个进程都在操作系统中有一个对应的PCB

#### 进程控制块的使用
1. 进程创建
   1. 生成该进程的PCB
2. 进程终止
   1. 回收它的PCB
3. 进程的组织管理
   1. 通过对PCB的组织管理来实现

#### 进程控制块的内容
1. 进程标识信息
2. 处理机现场保存
3. **进程控制信息**

#### 进程控制信息
1. 调度和状态信息
   1. 调度进程和处理机适用情况
2. 进程间通信信息
   1. 进程间通信相关的各种标识
3. 存储管理信息
   1. 指向进程映像存储空间数据结构
4. 进程所用资源
   1. 进程使用的系统资源，如打开文件等
5. 有关数据结构连接信息
   1. 与PCB相关的进程队列

#### 进程控制块的组织
1. 链表
   1. 同一状态的进程，其PCB成一个链表，多个状态对应多个不同的链表
   2. 各状态的进程形成不同的链表：就绪链表、阻塞链表
2. 索引表
   1. 同一状态的进程归入一个索引表（由索引指向PCB），多个状态对应多个不同的索引表
   2. 各状态的进行形成不同的索引表：就绪索引表、阻塞索引表

### 进程状态
#### 进程的生命周期划分
1. 进程创建
2. 进程执行
3. 进程等待
4. 进程抢占
5. 进程唤醒
6. 进程结束

#### 进程创建
1. 引起进程创建的情况
   1. 系统初始化时
   2. 用户请求创建一个新进程
   3. 正在运行的进程执行了创建进程的系统调用

#### 进程执行
1. 内核选择一个就绪的进程，让它占用处理机并执行

#### 进程等待
1. 进程进入等待（阻塞）的情况：
   1. 请求并等待系统服务，无法马上完成
   2. 启动某种操作，无法马上完成
   3. 需要的数据没有到达

2. 只有进程本身才能知道何时需要等待某种事件的发生

#### 进程抢占
1. 进程会被抢占的情况：
   1. 高优先级进程就绪
   2. 进程执行当前时间用完

#### 进程唤醒
1. 唤醒进程的情况：
   1. 被阻塞进程需要的资源可被满足
   2. 被阻塞进程等待的事件到达
2. 进程只能被别的进程或操作系统唤醒

#### 进程结束
1. 进程结束的情况：
   1. 正常退出（自愿的）
   2. 错误退出（自愿的）
   3. 致命错误（强制性的）
   4. 被其他进程所杀（强制性的）

#### 进程切换
（理解例子）

### 三状态进程模型
（那张PPT上的图很重要！）
1. 运行状态（Running）
   1. 进程正在处理机上运行
2. 就绪状态（Ready）
   1. 进程获得了除处理机之外的所需资源，得到处理机即可运行 
3. 等待状态（阻塞状态Blocked）
   1. 进程正在等待某一事件的出现而暂停运行
4. 创建状态（New）
   1. 一个进程正在被创建，还没被转到就绪状态之前的状态
5. 结束状态（Exit）
   1. 一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致

#### 模型状态转移
1. NULL -> 创建
2. 创建 -> 就绪
3. 就绪 -> 运行
4. 运行 -> 结束
5. 运行 -> 就绪
6. 运行 -> 等待
7. 等待 -> 就绪

### 挂起进程模型
#### 进程挂起
1. 处于挂起状态的进程映像在磁盘上，目的是减少进程占用内存。
   1. 等待挂起状态（Blocked-suspend）
      1. 进程在外存并等待某事件的出现
   2. 就绪挂起状态（Ready-suspend）
      1. 进程在外存，但只要进入内存即可运行

#### 与挂起相关的状态转换
1. 挂起（Suspend）
   1. 把一个进程从内存转到外存
      1. 等待到等待挂起
         1. 没有进程处于就绪状态，或就绪进程要求更多内存资源
      2. 就绪到就绪挂起
         1. 当有高优先级等待（系统认为会很快就绪的）进程和低优先级就绪进程
      3. 运行到就绪挂起
         1. 对抢先式分时系统，当有高优先级等待挂起进程因事件出现而进入就绪挂起
   2. 在外存时的状态转换
      1. 等待挂起到就绪挂起
         1. 当有等待挂起进程因相关事件出现
2. 激活（Activate）：把一个进程从外存转到内存
   1. 就绪挂起到就绪
      1. 没有就绪进程或挂起就绪进程优先级高于就绪进程
   2. 等待挂起到等待
      1. 当有一个进程释放足够内存，并有高优先级等待挂起进程

#### 状态队列
1. 由操作系统来维护一组队列，表示系统中所有进程的当前状态
2. 不同队列表示不同状态
   1. 就绪队列、各种等待队列
3. 根据进程状态不同，进程PCB加入相应队列
   1. 进程状态变化时，它所在的PCB会从一个队列换到另一个

## 线程
### 为什么引入线程
多线程的解决思路：
1. 在进程内部增加一类实体，满足以下特性：
   1. 实体之间可以并发执行
   2. 实体之间共享相同的地址空间
2. 这种实体就是 **线程**。

### 线程的概念
1. 线程是进程的一部分，描述指令流执行状态。它是进程中的**指令执行流**的最小单元，是CPU**调度**的基本单位。
   1. 进程的资源分配角色：
      1. 进程由一组相关资源构成，包括地址空间（代码段、数据段）、打开的文件等各种资源
      2. 线程的处理机调度角色：线程描述在进程资源环境中的指令流执行状态
#### 线程=进程-共享资源
1. 线程的优点：
   1. 一个进程中可以同时存在多个线程
   2. 各个线程之间可以并发地执行
   3. 各个线程之间可以共享地址空间和文件等资源
2. 线程的缺点：
   1. 一个线程崩溃，会导致其所属进程的所有线程崩溃

#### 不同操作系统对线程的支持
1. 单进程系统(例如MS-DOS)
2. 多进程系统(例如传统UNIX)
3. 多线程系统(例如现代UNIX)
4. 单进程多线程系统(例如pSOS)

#### 线程与进程的比较
1. 进程是资源分配单位，线程是CPU调度单位
2. 进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈
3. 线程具有就绪、等待和执行三种基本状态和状态间的转换关系
4. 线程能减少并发执行的时间和空间开销
   1. 线程的创建时间比进程短
   2. 线程的终止时间比进程短
   3. 同一进程内的线程切换时间比进程短
   4. 由于同一进程的各线程间共享内存和文件资源，所以可以不通过内核进行直接通信

### 用户线程 
#### 线程的三种实现方式
1. 用户线程：在用户空间实现
   1. POSIX Pthreads, Mach C-threads, Solaris threads
2. 内核线程：在内核中实现
   1. Windows, Solaris, Linux
3. 轻量级进程：在内核中实现，支持用户线程
   1. Solaris (LightWeight Process)

#### 用户线程
1. 由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等

#### 用户线程的特征
1. 不依赖于操作系统的内核
   1. 内核不了解用户线程的存在
   2. 可用于不支持线程的多进程操作系统
2. 在用户空间实现的线程机制
   1. 每个进程有私有的线程控制块（TCB）列表
   2. TCB由线程库函数来维护
3. 同一进程内的用户线程切换速度快
   1. 无需用户态/核心态切换
4. 允许每个进程拥有自己的线程调度算法

#### 用户线程的不足
1. 线程发起系统调用而阻塞时，则整个进程进入等待
2. 不支持基于线程的处理及抢占
   1. 除非当前运行线程主动放弃，它所在进程的其他线程无法抢占CPU
3. 线程只能按进程分配CPU时间
   1. 多个线程进程中，每个线程的时间片较少

### 内核线程
1. 进程由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理

#### 内核线程的特征
1. 由内核维护PCB和TCB
2. 线程执行系统调用而被阻塞不影响其他线程
3. 线程的创建、终止和切换相对较大
   1. 通过系统调用/内核函数，在内核实现
4. 以线程为单位进行CPU时间分配
   1. 多线程的进程可获得更多CPU时间

#### 轻权进程（LightWeight Process）
内核支持的用户线程。一个进程可以有一个或多个轻量级进程，每个轻权进程由一个单独的内核线程来支持（Solaris/Linux）

#### 用户线程与内核线程的对应关系
1. 一对一（这种做法比较好）
2. 多对一
3. 多对多