<!--
 * @Description:
 * @Author: Hongyang_Yang
 * @Date: 2020-09-23 11:20:42
 * @LastEditors: Hongyang_Yang
 * @LastEditTime: 2020-09-24 16:11:18
-->

# 提纲

## 进程切换

## 进程创建

## 进程加载

## 进程等待与退出

## 进程切换

1. 进程切换（上下文切换）
   1. 暂停当前运行进程，从运行状态变成其他状态
   2. 调度另一个进程从就绪状态变成运行状态
2. 进程切换的要求

   1. 切换前，保存进程上下文
   2. 切换后，恢复进程上下文
   3. 快速切换

3. 进程生命周期的信息
   1. 寄存器（PC, SP, ...）
   2. CPU 状态
   3. 内存地址空间

### 进程控制块 PCB:内核的进程状态记录

1. 内核为每个进程维护了对应的进程控制块(PCB)
2. 内核将相同状态的进程的 PCB 放置在同一队列
   1. 就绪队列
   2. I/O 等待队列
      1. 每个设备一个队列
   3. 僵尸队列

## 进程创建

### 创建新进程

1. Windows 进程创建 API : CreateProcess(filename)
   1. 创建时关闭所有在子进程里的文件描述符
      1. CreateProcess(filename, CLOSE_FD)
   2. 创建时改变子进程的环境
      1. CreateProcess(filename, CLOSE_FD, new_envp)
   3. 等等
2. Unix 进程创建系统调用：fork/exec
   1. fork()把一个进程复制成两个进程
      1. parent(old PID), child(new PID)
   2. exec()用新程序来重写当前进程
      1. PID 没有改变
3. fork()创建一个继承的子进程
   1. 复制父进程的所有变量和内存
   2. 复制父进程的所有 CPU 寄存器（有一个寄存器例外，来区分父子进程）
4. fork()的返回值
   1. 子进程的 fork()返回 0
   2. 父进程的 fork()返回子进程标识符
   3. fork()返回值可方便后续使用，子进程可使用 getpid()获取 PID
5. fork()执行过程对于子进程而言，是在调用时间对父进程地址空间的一次复制
   1. 对于父进程 fork()返回 child PID，对于子进程返回值为 0

### 程序加载和执行

1. 系统调用 exec()加载新程序取代当前运行进程。

### Fork()的开销

1. fork()的实现开销
   1. 对子进程分配内存
   2. 复制父进程的内存和 CPU 寄存器到子进程里
   3. 开销昂贵
2. 在 99%的情况里，我们在调用 fork()之后调用 exec()
   1. 在 fork()操作中内存复制是没有作用的
   2. 子进程将可能关闭打开的文件和连接
   3. 为什么不能结合它们在一个调用中？（Windows 中是这么做的）
3. vfork()
   1. 创建进程时，不再创建一个同样的内存映像
   2. 一些时候称为轻量级 fork()
   3. 子进程应该几乎立即调用 exec()
   4. 现在使用 Copy on Write(COW)技术

## 进程加载

### 程序加载和执行系统调用 exec()

1. 允许进程“加载”一个完全不同的程序，并从 main 开始执行（即\_start）
2. 允许进程加载时指定启动参数（argc, argv）
3. exec 调用成功时
   1. 它是相同的进程...
   2. 但是运行了不同的程序
4. 代码段、堆栈和堆（heap）等完全重写

## 进程的等待与退出

### 父进程等待子进程

1. wait()系统调用用于父进程等待子进程的结束
   1. 子进程结束时通过 exit()向父进程返回一个值
   2. 父进程通过 wait()接受并处理返回值
2. wait()系统调用的功能
   1. 有子进程存活时，父进程进入等待状态，等待子进程的返回结果；当子进程调用 exit()时，唤醒父进程，将 exit 的返回值作为父进程中 wait 的返回值
   2. 有僵尸子进程等待时，wait()立即返回其中一个值
   3. 无子进程存活时，wait()立刻返回

### 进程的有序终止 exit()

1. 进程结束执行时调用 exit()，完成进程资源回收
2. exit()系统调用的功能
   1. 将调用参数作为进程的“结果”
   2. 关闭所有打开的文件等占用资源
   3. 释放内存
   4. 释放大部分进程相关的内核数据结构
   5. 检查是否父进程是存活着的
      1. 如果存活，保留结果的值，直到父进程需要它进入僵尸（zombie/defunct）状态
      2. 如果没有，它释放所有的数据结构，进程结束
   6. 清理所有等待的僵尸进程
3. 进程终止是最终的垃圾收集（资源回收）
